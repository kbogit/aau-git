<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="P_Rum_4_219" Id="{45c16cae-4513-4858-a1eb-76a1d467b43b}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM P_Rum_4_219
VAR
(*
Rummene er delt af en foldedør. Rum_4_217 har lysgruppe 1 på linje 1, og Rum_4_219 har lysgruppe 2 på linje 1. 
Gruppe i rum 4.217 afhænger af PIR-input med adr. L3S2, og gruppe i rum 4.219 afhænger af PIR-input med adr. L3S1, L3S3 og L3S4
Derfor oprettes to adskilte reguleringer og to adskilte sensorinput.
Når dørkontakt aktiveres, sammensættes senorinput, således de to grupper har samme PV. Ligeledes sammensættes knapfunktion.
Sammensætning af sensorinput foregår i P_Foldedoer_4_219.A_SensorLogic
Sammensætning af knapfunktion foregår i P_Foldedoer_4_219.A_ButtonLogic
*)


	fbLys								:  SH_Light.FB_Light_Type_A;
	stDaliSetup						: SH_Light.ST_DALI_RoomSetup :=
																				(		byShrtAdr_Prim := 1, 
																						byGrpAdr_Prim := 2, 
																						eMod_Prim := E_DALIAddressType.Group, 
																						byShrtAdr_Sec := 1, 
																						byGrpAdr_Sec := 1, 
																						eMod_Sec := E_DALIAddressType.Short, 
																						byShrtAdr_Supl := 1, 
																						byGrpAdr_Supl := 1,
																						eMod_Supl := E_DALIAddressType.Short,
																						DALI_LINE_NUM_PRIM := DALI_LINE_NUM_LIGHT, 
																						DALI_LINE_NUM_SEC := 0, 
																						DALI_LINE_NUM_SUPL := DALI_LINE_NUM_PENDANTS);
																						
														
	stLiveData						: SH_Light.ST_LiveData;
	bTopButtonZone1				: BOOL;
	bTopButtonZone1_Visu		: BOOL;
	bBottomButtonZone1			: BOOL;
	bBottomButtonZone1_Visu	: BOOL;
	bButtonZone2					: BOOL;
	fLuxOn								: REAL;
	fLuxDim							: REAL;
	tPIRDim							: TIME;
	tPIROff							: TIME;
	fOffsetSec						: REAL := 20;
	bOccupiedRoom				: BOOL;

	bRunTuning				: BOOL;
	

// Sensor Settings
	//rum 4.217
	//fbSensor						: SH_Light.FB_NIKO_P46xx_1Pcs;
	fbSensor							: SH_Light.FB_NIKO_P46xx_3Pcs;
	//bySensorAddr				: BYTE := 2;
	arrSensorAddr			: ARRAY[1..3] OF BYTE :=[1,3,4];  
	bInitialize						: BOOL := TRUE;
	stDaliSensorSetup			: ST_DALI_NIKOP46SetupData;
	//bInitErr							: BOOL;
	arrInitErr						: ARRAY [1..3] OF BOOL;
	//bInitDone						: BOOL;
	arrInitDone					: ARRAY [1..3] OF BOOL;
	arrSensorScales				: ARRAY [1..10] OF SH_Light.ST_DALI_SensorScaleMode := [ 	                                                (fMeassureMaxSensor := rMeassure_Zone5, fReadMaxSensor := rRead_Zone5),
																																			(fMeassureMaxSensor := rMeassure_Zone5, fReadMaxSensor := rRead_Zone5),
																																			(fMeassureMaxSensor := rMeassure_Zone5, fReadMaxSensor := rRead_Zone5),
																																			7(())];
																					
	bCancelHoldTimerOccupancy	: BOOL;
	
(*	eEventPriorityOccupancy		: E_DALIEventPriority := E_DALIEVENTPRIORITY.Middle;
	nHoldTimerOccupancy			: WORD := 5; // Value in s. 	
	nReportTimerOccupancy		: BYTE := 120; // Value in s, Preset manufacturer value
	nDeadtimeTimerOccupancy		: WORD := 100; // Value in ms, Predefined Value of DALI Standard
	bCancelHoldTimerOccupancy	: BOOL;
	nSensitivityOccupancy		: BYTE:= 3; //setting Sensivity (0..4) 0 (Off), 1 (Min), 2(Low), 3(High) and 4 (Max)

	bEnableLuxEvent				: BOOL;
	eEventPriorityBrightness	: E_DALIEventPriority := E_DALIEVENTPRIORITY.Middle;
	nDeadtimeTimerBrightness	: WORD := 1500; // Value in ms, Predefined Value of DALI Standard
	nHysteresisBrightness		: BYTE := 2; // Value in %
	nHysteresisMinBrightness	: BYTE := 10; // Absolute Value, depending on the manufacturer specific resolution
	nReportTimerBrightness		: BYTE := 120; // Value in s, Preset manufacturer value
*)

	//ModbusComm setup
	
	fbWriteSPLuxLevel				: SH_Light.FB_TwoVal_SelectOne_RTrigChange;
	fbWritePirDelayTime				: SH_Light.FB_TwoVal_SelectOne_RTrigChange;
	stRoomDataPLC					: SH_Light.ST_RoomDataPLC	:=	(	uiPirOffDelayTime	:= 30,
																										uiSpLuxLevel			:= 500,
																										uiPirDimDelayTime	:= 15,
																										uiSpDimLuxLevel		:= 200);
																
	fbBallastOnHours					: SH_Light.FB_CountOnHours;
	bEnableHourCount				: BOOL := TRUE;
	
	//Non-persistent modbus data
	bPirActive_MB					AT %MX196.0	: BOOL;				//bPirLys i gammel kode
	uiActLuxLevel_MB			AT %MB200	: UINT;				//intHMIAktueltLux i gammel kode
	uiActLightLevelPct_MB	AT %MB208	: UINT;				//intDALI_Gruppe1_Lysniveau i gammel kode
	
	//For Conversion
	uiPirOffMinutes						: UINT;
	udTimeScaling						: UDINT :=	60000;
	uiLuxOn								: UINT;
	
	//max values checks
	uiMaxLuxLevel						: UINT := 1023;
	uiMaxPirOffMinutes				: UINT := 180;

END_VAR

VAR CONSTANT
	Sensor_DALI_LINE_NUM				: BYTE := 3;
	DALI_LINE_NUM_LIGHT     		: BYTE  := 1;
	DALI_LINE_NUM_PENDANTS	: BYTE := 0;
END_VAR
VAR PERSISTENT
    stPirSensorData: SH_Light.ST_DALI_Sensor;
	stTuneData: SH_Light.ST_TuneData_EX;
	
	uiPirOffDelayTime_MB		AT %MB198	: UINT;				//ntHMI_Pir_SetValue i gammel kode
	uiSPLuxLevel_MB			AT %MB204	: UINT;				//intHMI_Lux_SetValue i gammel kode
	uiBallastOnHours_MB		AT %MB212	: UINT;				//dintHMILysbraendtimer1 i gammel kode
	byOnHoursOverflowCount				: BYTE;
END_VAR


]]></Declaration>
    <Implementation>
      <ST><![CDATA[A_Buttons();
A_LightCtrl();
A_ModbusComm();
A_Sensor();
]]></ST>
    </Implementation>
    <Action Name="A_Buttons" Id="{caa7e086-9a6e-4601-bcb3-29df2b120a10}">
      <Implementation>
        <ST><![CDATA[bTopButtonZone1		:= P_Foldedoer_4_219.arrTopButtonZone1Comb[2] OR bTopButtonZone1_Visu;
bBottomButtonZone1	:= P_Foldedoer_4_219.arrBottomButtonZone1Comb[2] OR bBottomButtonZone1_Visu;]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_LightCtrl" Id="{fea769c9-3022-4450-86e7-37265ee5d5f6}">
      <Implementation>
        <ST><![CDATA[//gruppe 1 L1
fbLys( 
	nZoneID:= 1, 
	bButtonZone1:= bTopButtonZone1,
	bBottomButtonZone1 := bBottomButtonZone1,
	bButtonZone2:= bButtonZone2,
	fLuxOn:= fLuxOn, 
	fLuxDim:= fLuxDim, 
	tPIRDim:= tPIRDim, 
	tPIROff:= tPIROff, 
	fOffsetSec:= fOffsetSec, 
	bReInit:= , 
	stDaliSetup:= stDaliSetup, 
	ipCommunication_Prim:= P_DALI_Background.arrfbKL6821Communication[DALI_LINE_NUM_LIGHT], 
	//ipCommunication_Sec:= P_DALI_Background.arrfbKL6821Communication[DALI_LINE_NUM_LIGHT], 
	//ipCommunication_Supl:= P_DALI_Background.arrfbKL6821Communication[DALI_LINE_NUM_PENDANTS],
	fMinOutputPowerLevelRoom:= 15, 
	fMaxOutputPowerLevelRoom:= 100, 
	nCycleTimeInMS:= SH_Light.DALI_Param.nPlcTaskCycleTimeInMS*nDimCmdCycleTimeFactor , 
	bRunTuning:= bRunTuning, 
	bOccupiedRoom=> , 
	bError_Prim=> , 
	nError_Prim=> , 
	stTuneData:=stTuneData , 
	stPirSensorData:= P_Foldedoer_4_219.arrstPirSensorDataComb[2], 					
	stLiveData:= stLiveData);
]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_ModbusComm" Id="{80790647-dfa6-44d5-ab48-fe9d2354e3d2}">
      <Implementation>
        <ST><![CDATA[//Manage data for modbus communication

//Manage data for read-only in PLC
stRoomDataPLC.bPirActive			:= stPirSensorData.bPrc;
stRoomDataPLC.uiActLuxLevel			:= TO_UINT(TRUNC(stPirSensorData.fBrightness));
stRoomDataPLC.uiActLightLevelPct	:= TO_UINT(TRUNC(fbLys.fbBallast.fActlLgtLvl_Prim));
		//stRoomDataPLC.uiActLightLevelPct	:= TO_UINT(TRUNC(fbLys.fbBallast.fActlLgtLvl_Prim)); //if only one group light control
stRoomDataPLC.uiBallastOnHours		:= uiBallastOnHours_MB; //The calculation for BallastOnHours is stored directly to the MB register below


//Assign data for read-only to MB registers
bPirActive_MB			:= stRoomDataPLC.bPirActive;
uiActLuxLevel_MB		:= stRoomDataPLC.uiActLuxLevel;
uiActLightLevelPct_MB	:= stRoomDataPLC.uiActLightLevelPct;

	//calculate BallastOnHours
	fbBallastOnHours(
		bEnableHourCount	:= bEnableHourCount,
		bPauseCount			:= fbLys.fbLightCtrl.bOffZone1,
		uiOnHours			:= uiBallastOnHours_MB,			//OnHours is updated here
		byOverflowCount		:= byOnHoursOverflowCount);


//Manage data for read/write for both PLC and MB registers
fbWriteSPLuxLevel(	nMaxValOut	:= uiMaxLuxLevel,
					nValIn1		:= uiSPLuxLevel_MB,		//nValIn1 takes priotity in case of download or restart
					nValIn2		:= stRoomDataPLC.uiSpLuxLevel,
					nValOut		=> uiLuxOn
				);


fbWritePirDelayTime(	nMaxValOut	:= uiMaxPirOffMinutes,
						nValIn1		:= uiPirOffDelayTime_MB,		//nValIn1 takes priority in case of download or restart
						nValIn2		:= stRoomDataPLC.uiPirOffDelayTime,
						nValOut		=> uiPirOffMinutes
					);
					

//Convert read/write modbus data to appropriate datatypes in PLC
fLuxOn	:= TO_REAL(uiLuxOn);			
tPIROff	:= TO_TIME(uiPirOffMinutes*udTimeScaling); //Time conversion defaults to ms

fLuxDim	:= TO_REAL(stRoomDataPLC.uiSpDimLuxLevel);			
tPIRDim	:= TO_TIME(stRoomDataPLC.uiPirDimDelayTime*udTimeScaling); //Time conversion defaults to ms
]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_Sensor" Id="{4f902c13-4c3d-4642-a421-24262a91bf70}">
      <Implementation>
        <ST><![CDATA[
fbSensor.ipCommunication := P_DALI_Background.arrfbKL6821Communication[Sensor_DALI_LINE_NUM];

(*//only 1 sensor
fbSensor(
	byShrtAdr:= bySensorAddr,
	bInitialize:= bInitialize, 
	DALI_LINE_NUM:= Sensor_DALI_LINE_NUM, 
 	//bCancelHoldTimerOccupancy:= bCancelHoldTimerOccupancy, 
	stSensorSetup := stDaliSensorSetup,
	bInitErr=> bInitErr, 
	bInitDone=> bInitDone,
	stPirSensorData:= stPirSensorData, 
	arrSensorScales:= arrSensorScales);
*)

fbSensor(
	arrShrtAdr:= arrSensorAddr,
	bInitialize:= bInitialize, 
	DALI_LINE_NUM:= Sensor_DALI_LINE_NUM, 
 	//bCancelHoldTimerOccupancy:= bCancelHoldTimerOccupancy, 
	stSensorSetup := stDaliSensorSetup,
	arrInitErr=> arrInitErr, 
	arrInitDone=> arrInitDone,
	stPirSensorData:= P_Foldedoer_4_219.arrstPirSensorData[2], 
	arrSensorScales:= arrSensorScales);
	
	stPirSensorData := P_Foldedoer_4_219.arrstPirSensorData[2]; //For at holde samme navngivning i A_ModbusComm
	]]></ST>
      </Implementation>
    </Action>
  </POU>
</TcPlcObject>