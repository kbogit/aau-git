<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="P_Gang_6_210" Id="{58a7ad0a-1030-490b-a33b-643c95ca58a8}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM P_Gang_6_210
(*
Gangen består af en lysgruppe og et ekstra armatur - L2G2 og L1S38 - på to forskellige linjer
både gruppe og ekstra armatur afhænger af samme PIR-input : pir-adr. 5, 6 og 10 på DALI-linje 2 og pir-adr. 4 på DALI-linje 4
Derfor oprettes to adskilte reguleringer med samme PV. Dvs., at knapfunktion og pirfunktion forbliver den samme.
Der oprettes to sensor setups, som samles i A_Sensor.
Gangen nabostyres af Gang_1_216 fra AH2-2 og udvalgte rum på gangen
*)
VAR
	arrfbLysGruppe			: ARRAY [1..2] OF FB_Light_Type_B;
	arrstDaliSetupGruppe	: ARRAY[1..2] OF SH_Light.ST_DALI_RoomSetup := 
	
													[(	byShrtAdr_Prim	    := 27, 
														byGrpAdr_Prim		:= 6, 
														eMod_Prim			:= E_DALIAddressType.Group, 
														//byShrtAdr_Sec		:= 1, 
														//byGrpAdr_Sec		:= 1, 
														//eMod_Sec			:= E_DALIAddressType.Short, 
														byShrtAdr_Supl		:= 28,
														//byGrpAdr_Supl := 1,
														eMod_Supl			:= E_DALIAddressType.Short,
														DALI_LINE_NUM_PRIM	:= arrDALI_LINE_NUM_LIGHT[1], 
														DALI_LINE_NUM_SEC		:= 0, //0 = ingen zonestyring/vinduerække
														DALI_LINE_NUM_SUPL	:= arrDALI_LINE_NUM_PENDANTS[1]),
														
													(	byShrtAdr_Prim	    := 36, 
														byGrpAdr_Prim		:= 6, 
														eMod_Prim			:= E_DALIAddressType.Group, 
														//byShrtAdr_Sec		:= 1, 
														//byGrpAdr_Sec		:= 1, 
														//eMod_Sec			:= E_DALIAddressType.Short, 
														//byShrtAdr_Supl		:= 1,
														//byGrpAdr_Supl := 1,
														//eMod_Supl			:= E_DALIAddressType.Short, 
														DALI_LINE_NUM_PRIM	:= arrDALI_LINE_NUM_LIGHT[2], 
														DALI_LINE_NUM_SEC		:= 0, 
														DALI_LINE_NUM_SUPL	:= arrDALI_LINE_NUM_PENDANTS[2])];
	
	arrstLiveDataGruppe			: ARRAY [1..2] OF SH_Light.ST_LiveData;
	arrRunTuningGruppe			: ARRAY[1..2] OF BOOL;
	
	bTopButtonZone1				    : BOOL;
	bTopButtonZone1_Visu		    : BOOL;
	bBottomButtonZone1			    : BOOL;
	bBottomButtonZone1_Visu	        : BOOL;
	bButtonZone2					: BOOL;
	bNeighborRoomsPir			    : BOOL;
	fLuxOn							: REAL;
	fLuxDim							: REAL;
	tPIRDim							: TIME;
	tPIROff							: TIME;
	fOffsetSec						: REAL := 20;
	bOccupiedRoom				    : BOOL;

// Sensor Settings
	fbSensor						: SH_Light.FB_NIKO_P46xx_2Pcs;
	arrSensorAddr				    : ARRAY[1..2] OF BYTE :=[3,4];  
	bInitialize						: BOOL := TRUE;
	stDaliSensorSetup			    : ST_DALI_NIKOP46SetupData;
	arrInitErr						: ARRAY [1..2] OF BOOL;
	arrInitDone					    : ARRAY [1..2] OF BOOL;
	arrSensorScales				    : ARRAY [1..10] OF SH_Light.ST_DALI_SensorScaleMode := [
																							(fMeassureMaxSensor := rMeassure_Zone10, fReadMaxSensor := rRead_Zone10),
																							(fMeassureMaxSensor := rMeassure_Zone10, fReadMaxSensor := rRead_Zone10),
																							8(())];
	
	//Setup af sensorer på forskellige linjer kan ikke håndteres med ARRAYS som sædvanlig, da der kun er 1 sensor på setup 2.
	fbSensor2					: SH_Light.FB_NIKO_P46xx_1Pcs;
	bySensor2Addr				: BYTE := 13;
	bInitialize2				: BOOL := TRUE;
	stDaliSensor2Setup		    : ST_DALI_NIKOP46SetupData;
	bInitErr2					: BOOL;
	bInitDone2					: BOOL;
	arrSensor2Scales			: ARRAY [1..10] OF SH_Light.ST_DALI_SensorScaleMode := [
																							(fMeassureMaxSensor := rMeassure_Zone10, fReadMaxSensor := rRead_Zone10),
																							9(())];
																					
	bCancelHoldTimerOccupancy	: BOOL;
	
(*	eEventPriorityOccupancy		: E_DALIEventPriority := E_DALIEVENTPRIORITY.Middle;
	nHoldTimerOccupancy			: WORD := 5; // Value in s. 	
	nReportTimerOccupancy		: BYTE := 120; // Value in s, Preset manufacturer value
	nDeadtimeTimerOccupancy		: WORD := 100; // Value in ms, Predefined Value of DALI Standard
	bCancelHoldTimerOccupancy	: BOOL;
	nSensitivityOccupancy		: BYTE:= 3; //setting Sensivity (0..4) 0 (Off), 1 (Min), 2(Low), 3(High) and 4 (Max)

	bEnableLuxEvent				: BOOL;
	eEventPriorityBrightness	: E_DALIEventPriority := E_DALIEVENTPRIORITY.Middle;
	nDeadtimeTimerBrightness	: WORD := 1500; // Value in ms, Predefined Value of DALI Standard
	nHysteresisBrightness		: BYTE := 2; // Value in %
	nHysteresisMinBrightness	: BYTE := 10; // Absolute Value, depending on the manufacturer specific resolution
	nReportTimerBrightness		: BYTE := 120; // Value in s, Preset manufacturer value
*)

	//ModbusComm setup
	
	fbWriteSPLuxLevel				: SH_Light.FB_TwoVal_SelectOne_RTrigChange;
	fbWritePirDelayTIme		     	: SH_Light.FB_TwoVal_SelectOne_RTrigChange;
	stRoomDataPLC					: SH_Light.ST_RoomDataPLC	:=	(
																		uiPirOffDelayTime	:= 30,
																		uiSpLuxLevel			:= 500,
																		uiPirDimDelayTime	:= 15,
																		uiSpDimLuxLevel		:= 200);
																		
	fbBallastOnHours				: SH_Light.FB_CountOnHours;
	bEnableHourCount			    : BOOL := TRUE;
	
	//Non-persistent modbus data
	bPirActive_MB					AT %MX482.0	    : BOOL;				//bPirLys i gammel kode
	uiActLuxLevel_MB		     	AT %MB512		: UINT;				//intHMIAktueltLux i gammel kode
	uiActLightLevelPct_MB	        AT %MB516		: UINT;				//intDALI_Gruppe1_Lysniveau i gammel kode
	
	//For Conversion
	uiPirOffMinutes						: UINT;
	udTimeScaling						: UDINT := 60000;
	uiLuxOn								: UINT;
	
	//max values checks
	uiMaxLuxLevel						: UINT := 1023;
	uiMaxPirOffMinutes				    : UINT := 180;

END_VAR

VAR CONSTANT
	Sensor_DALI_LINE_NUM		: BYTE := 2;
	Sensor2_DALI_LINE_NUM	    : BYTE := 3;
    arrDALI_LINE_NUM_LIGHT      : ARRAY[1..2] OF BYTE := [1,2]; //korrekt rækkefølge nødvendig //rækkefølge og linje 
	arrDALI_LINE_NUM_PENDANTS   : ARRAY[1..2] OF BYTE := [1,0]; //korrekt rækkefølge nødvendig. 0 = ingen pendler
END_VAR
VAR PERSISTENT
	stPirSensorData			: SH_Light.ST_DALI_Sensor;
	arrstPirSensorDataLine	: ARRAY[1..2] OF SH_Light.ST_DALI_Sensor;
	arrstTuneDataGruppe	    : ARRAY [1..2] OF SH_Light.ST_TuneData_EX;
	
	uiPirOffDelayTime_MB		AT %MB510	: UINT;				//ntHMI_Pir_SetValue i gammel kode
	uiSPLuxLevel_MB			    AT %MB514	: UINT;				//intHMI_Lux_SetValue i gammel kode
	uiBallastOnHours_MB		    AT %MB518	: UINT;				//dintHMILysbraendtimer1 i gammel kode
	byOnHoursOverflowCount						: BYTE;
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[A_Buttons();
A_LightCtrl();
A_ModbusComm();
A_Sensor();
]]></ST>
    </Implementation>
    <Action Name="A_Buttons" Id="{d6490d8b-020a-4cd3-b242-9ed8fcbd833d}">
      <Implementation>
        <ST><![CDATA[bTopButtonZone1		:= bTopButtonZone1_Visu;
bBottomButtonZone1	:= bBottomButtonZone1_Visu;
]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_LightCtrl" Id="{a4fb11d3-729c-49b5-9612-511bf11ee33a}">
      <Implementation>
        <ST><![CDATA[bNeighborRoomsPir := P_Gang_5_238.stPirSensorData.bPrc  OR
                     P_Gang_5_266A.stPirSensorData.bPrc OR 
                     P_Rum_6_212.stPirSensorData.bPrc   OR
                     P_Rum_6_214A.stPirSensorData.bPrc  OR
                     P_Rum_6_216A.stPirSensorData.bPrc  OR
                     P_Rum_6_218A.stPirSensorData.bPrc  OR
                     P_Rum_6_220.stPirSensorData.bPrc   OR
                     P_Rum_6_222.stPirSensorData.bPrc   OR
                     P_Rum_6_205.stPirSensorData.bPrc   OR
                     P_Rum_6_209.stPirSensorData.bPrc   OR
                     P_Rum_6_211.stPirSensorData.bPrc   OR
                     P_Rum_6_213.stPirSensorData.bPrc   OR
                     P_Rum_6_215.stPirSensorData.bPrc   OR
                     P_Rum_6_217_1.stPirSensorData.bPrc OR
                     P_Rum_6_219.stPirSensorData.bPrc   OR
                     P_Rum_6_221.stPirSensorData.bPrc   OR
                     P_Rum_6_214B.stPirSensorData.bPrc  OR
                     P_Rum_6_216B.stPirSensorData.bPrc  OR
                     P_Rum_6_218B.stPirSensorData.bPrc  OR
                     GVL_AHDataModbus.arrAH_NeighborRoomsPir[2][1] ;

arrfbLysGruppe[1]( 
	nZoneID:= 1,  
	bButtonZone1:= bTopButtonZone1,
	bBottomButtonZone1 := bBottomButtonZone1, 
	//bButtonZone2:= bButtonZone2,
	bNoButtons := TRUE,
	bNeighborRoomsPir := bNeighborRoomsPir,
	fLuxOn:= fLuxOn, 
	fLuxDim:= fLuxDim, 
	tPIRDim:= tPIRDim, 
	tPIROff:= tPIROff, 
	fOffsetSec:= fOffsetSec, 
	bReInit:= , 
	stDaliSetup:= arrstDaliSetupGruppe[1], 
	ipCommunication_Prim:= P_DALI_Background.arrfbKL6821Communication[arrDALI_LINE_NUM_LIGHT[1]], 
	//ipCommunication_Sec:= P_DALI_Background.arrfbKL6821Communication[arrDALI_LINE_NUM_LIGHT[1]],
	ipCommunication_Supl:= P_DALI_Background.arrfbKL6821Communication[arrDALI_LINE_NUM_PENDANTS[1]],
	fMinOutputPowerLevelRoom:= 15, 
	fMaxOutputPowerLevelRoom:= 100, 
	nCycleTimeInMS:= SH_Light.DALI_Param.nPlcTaskCycleTimeInMS*nDimCmdCycleTimeFactor , 
	bRunTuning:= arrRunTuningGruppe[1], 
	bOccupiedRoom=> , 
	bError_Prim=> , 
	nError_Prim=> , 
	stTuneData:=arrstTuneDataGruppe[1] , 
	stPirSensorData:= stPirSensorData, 					//samme sensordata
	stLiveData:= arrstLiveDataGruppe[1]);

	
arrfbLysGruppe[2]( 
	nZoneID:= 1, 
	bButtonZone1:= bTopButtonZone1,
	bBottomButtonZone1 := bBottomButtonZone1,
	//bTopButtonOverride := ,
	//bBottomButtonOverride := ,
	//bButtonZone2:= bButtonZone2,
	//bNoButtons := TRUE,
	bNeighborRoomsPir	:=	bNeighborRoomsPir,
	fLuxOn:= fLuxOn, 
	fLuxDim:= fLuxDim, 
	tPIRDim:= tPIRDim, 
	tPIROff:= tPIROff, 
	fOffsetSec:= fOffsetSec, 
	bReInit:= , 
	stDaliSetup:= arrstDaliSetupGruppe[2], 
	ipCommunication_Prim:= P_DALI_Background.arrfbKL6821Communication[arrDALI_LINE_NUM_LIGHT[2]], 
	//ipCommunication_Sec:= P_DALI_Background.arrfbKL6821Communication[arrDALI_LINE_NUM_LIGHT[2]],
	//ipCommunication_Supl:= P_DALI_Background.arrfbKL6821Communication[arrDALI_LINE_NUM_PENDANTS[2]],
	fMinOutputPowerLevelRoom:= 15, 
	fMaxOutputPowerLevelRoom:= 100, 
	nCycleTimeInMS:= SH_Light.DALI_Param.nPlcTaskCycleTimeInMS*nDimCmdCycleTimeFactor , 
	bRunTuning:= arrRunTuningGruppe[2], 
	bOccupiedRoom=> , 
	bError_Prim=> , 
	nError_Prim=> , 
	stTuneData:=arrstTuneDataGruppe[2] , 
	stPirSensorData:= stPirSensorData, 					//samme sensordata
	stLiveData:= arrstLiveDataGruppe[2]);	]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_ModbusComm" Id="{2f9fbb06-ceab-47e4-b4cd-b50b1cb6427b}">
      <Implementation>
        <ST><![CDATA[//Manage data for modbus communication

//Manage data for read-only in PLC
stRoomDataPLC.bPirActive			:= stPirSensorData.bPrc;
stRoomDataPLC.uiActLuxLevel			:= TO_UINT(TRUNC(stPirSensorData.fBrightness));
stRoomDataPLC.uiActLightLevelPct	:= TO_UINT(TRUNC(arrfbLysGruppe[1].fbBallast.fActlLgtLvl_Prim));
		//stRoomDataPLC.uiActLightLevelPct	:= TO_UINT(TRUNC(fbLys.fbBallast.fActlLgtLvl_Prim)); //if only one group light control
stRoomDataPLC.uiBallastOnHours		:= uiBallastOnHours_MB; //The calculation for BallastOnHours is stored directly to the MB register below


//Assign data for read-only to MB registers
bPirActive_MB			:= stRoomDataPLC.bPirActive;
uiActLuxLevel_MB		:= stRoomDataPLC.uiActLuxLevel;
uiActLightLevelPct_MB	:= stRoomDataPLC.uiActLightLevelPct;

	//calculate BallastOnHours
	fbBallastOnHours(
		bEnableHourCount	:= bEnableHourCount,
		bPauseCount			:= arrfbLysGruppe[1].fbLightCtrl.bOffZone1,
		uiOnHours			:= uiBallastOnHours_MB,			//OnHours is updated here
		byOverflowCount		:= byOnHoursOverflowCount);


//Manage data for read/write for both PLC and MB registers
fbWriteSPLuxLevel(	nMaxValOut	:= uiMaxLuxLevel,
					nValIn1		:= uiSPLuxLevel_MB,		//nValIn1 takes priotity in case of download or restart
					nValIn2		:= stRoomDataPLC.uiSpLuxLevel,
					nValOut		=> uiLuxOn
				);


fbWritePirDelayTIme(	nMaxValOut	:= uiMaxPirOffMinutes,
						nValIn1		:= uiPirOffDelayTime_MB,		//nValIn1 takes priotity in case of download or restart
						nValIn2		:= stRoomDataPLC.uiPirOffDelayTime,
						nValOut		=> uiPirOffMinutes
					);
					

//Convert read/write modbus data to appropriate datatypes in PLC
fLuxOn	:= TO_REAL(uiLuxOn);			
tPIROff	:= TO_TIME(uiPirOffMinutes*udTimeScaling); //Time conversion defaults to ms

fLuxDim	:= TO_REAL(stRoomDataPLC.uiSpDimLuxLevel);			
tPIRDim	:= TO_TIME(stRoomDataPLC.uiPirDimDelayTime*udTimeScaling); //Time conversion defaults to ms
]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_Sensor" Id="{9523b504-de9f-4f6d-8d7c-9a3911230b97}">
      <Implementation>
        <ST><![CDATA[fbSensor2.ipCommunication := P_DALI_Background.arrfbKL6821Communication[Sensor2_DALI_LINE_NUM];
fbSensor.ipCommunication := P_DALI_Background.arrfbKL6821Communication[Sensor_DALI_LINE_NUM];

//only 1 sensor
fbSensor2(
	byShrtAdr:= bySensor2Addr,
	bInitialize:= bInitialize2, 
	DALI_LINE_NUM:= Sensor2_DALI_LINE_NUM, 
 	//bCancelHoldTimerOccupancy:= bCancelHoldTimerOccupancy, 
	stSensorSetup := stDaliSensor2Setup,
	bInitErr=> bInitErr2, 
	bInitDone=> bInitDone2,
	stPirSensorData:= arrstPirSensorDataLine[2], 
	arrSensorScales:= arrSensor2Scales);


fbSensor(
	arrShrtAdr:= arrSensorAddr,
	bInitialize:= bInitialize, 
	DALI_LINE_NUM:= Sensor_DALI_LINE_NUM, 
 	//bCancelHoldTimerOccupancy:= bCancelHoldTimerOccupancy, 
	stSensorSetup := stDaliSensorSetup,
	arrInitErr=> arrInitErr, 
	arrInitDone=> arrInitDone,
	stPirSensorData:= arrstPirSensorDataLine[1], 
	arrSensorScales:= arrSensorScales);
	
//Input fra sensorer samles
stPirSensorData.fBrightness		:= MIN(arrstPirSensorDataLine[1].fBrightness, arrstPirSensorDataLine[2].fBrightness);
stPirSensorData.bPrc				:= arrstPirSensorDataLine[1].bPrc OR arrstPirSensorDataLine[2].bPrc;
stPirSensorData.bBrightnessRead	:= arrstPirSensorDataLine[1].bBrightnessRead OR arrstPirSensorDataLine[2].bBrightnessRead;

//Output til sensorer fordeles
IF stPirSensorData.bQueryBrightness THEN
	arrstPirSensorDataLine[1].bQueryBrightness := TRUE;
	arrstPirSensorDataLine[2].bQueryBrightness := TRUE;
ELSE
	arrstPirSensorDataLine[1].bQueryBrightness := FALSE;
	arrstPirSensorDataLine[2].bQueryBrightness := FALSE;
END_IF
	]]></ST>
      </Implementation>
    </Action>
  </POU>
</TcPlcObject>