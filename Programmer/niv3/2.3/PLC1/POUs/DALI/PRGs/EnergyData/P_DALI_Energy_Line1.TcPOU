<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="P_DALI_Energy_Line1" Id="{25f28d73-4faf-4ed2-b50a-a52f5949883b}" SpecialFunc="None">
    <Declaration><![CDATA[(*
EnergyReporting reads ActiveEnergy (part 252) for all present ballasts on all (configured) DALI-lines where GVL_DALI.g_arrEnergyData[*DALI-line*,*ballast*].bHasEnergyData is TRUE.
Results are stored in GVL_DALI.g_arrEnergyData[*DALI-line*,*ballast*].fActiveEnergy. Energy Data for individual ballasts is NOT persistent.
The engergy sum per DALI-Line (Wh) and Total Energy (kWh) are persistent.

If bCheckActiveEnergy is TRUE, all present ballasts are queried for ActiveEnergy and bHasEnergyData is updated accordingly.
This will result in errors for any ballast that does not comply with part 252.
Errors will not be triggered for activations where bCheckActiveEnergy is FALSE.

After shutdown or download to PLC EnergyReporting is activated automatically internally with bCheckActiveEnergy set to TRUE

EnergyReporting is activated automatically at TOD 0:00, 6:00, 12:00, 18:00 (configurable)

NB:	The priority of commands are set to "middle" internally. Updating all lines will take a couple of minutes to finish, so be patient.
	Other critical commands on the DALI-lines take priotity.
	Add appropriate communication immediately after configuration of a new KL6821 terminal.
	That is, arrfbDALI_EnergyReporting[*DALI-Line*].ipDALICommunication := P_DALI_Background.arrfbKL6821Communication[*DALI-Line*];
*)


PROGRAM P_DALI_Energy_Line1
VAR
	arrfbDALI_EnergyReporting	: ARRAY[1..SH_Light.DALI_Param.MAX_DALIV2_LINES] OF FB_DALI_EnergyReporting_Test;
	bReadEnergyDataAllLines		: BOOL;
	arrReadEnergyData			: ARRAY[1..SH_Light.DALI_Param.MAX_DALIV2_LINES] OF BOOL;
	arrCheckActiveEnergy		: ARRAY[1..SH_Light.DALI_Param.MAX_DALIV2_LINES] OF BOOL;
	arrDone						: ARRAY[1..SH_Light.DALI_Param.MAX_DALIV2_LINES] OF BOOL;
	arrfbRTrigDone				: ARRAY[1..SH_Light.DALI_Param.MAX_DALIV2_LINES] OF R_TRIG;
	arrRTrigDone				: ARRAY[1..SH_Light.DALI_Param.MAX_DALIV2_LINES] OF BOOL;
	
	byEnergyLineIdx: BYTE;
	
	//variables to store persistent data correctly
	byCount								: BYTE;
	nMaxControlGearOperatingTimeTmp		: ARRAY[1..SH_Light.DALI_Param.MAX_DALIV2_LINES] OF UDINT;
	nMaxControlGearOperatingTime		: ARRAY[1..SH_Light.DALI_Param.MAX_DALIV2_LINES] OF UDINT;
	nMaxControlGearOperatingHoursTmp	: UINT;
	//byShrtAddrOfMostUsedBallast		: ARRAY[1..SH_Light.DALI_Param.MAX_DALIV2_LINES] OF BYTE;
	fDaliLineEnergySumTmp				: ARRAY[1..SH_Light.DALI_Param.MAX_DALIV2_LINES] OF LREAL;
	fDaliLineEnergySumOld				: ARRAY[1..SH_Light.DALI_Param.MAX_DALIV2_LINES] OF LREAL;
	fDaliLineEnergyChange				: ARRAY[1..SH_Light.DALI_Param.MAX_DALIV2_LINES] OF LREAL;
	nTotalEnergyKWHTmp					: UINT;
	
	//Task scheduling
	stLocalSystemTime 		: TIMESTRUCT;
	fbLocalSystemTime 		: FB_LocalSystemTime;
	bGetTime 				: BOOL := TRUE;
	tTimeOut 				: TIME := DEFAULT_ADS_TIMEOUT;
	bLocalSystemTimeValid	: BOOL;
	tzID       				: E_TimeZoneID := eTimeZoneID_Invalid;
	
	tdSystemTime			: TOD;
	btestTodCompare			: BOOL;
	
	
END_VAR
VAR CONSTANT
	tdMidnight						: TOD := TOD#0:0:0;
	tdMorning						: TOD := TOD#6:0:0;
	tdMidDay						: TOD := TOD#12:0:0;
	tdEvening						: TOD := TOD#18:0:0;
	tCheckDuration					: TIME:= T#5S;
	tdTestsum						: TOD := (tdMidnight + tCheckDuration);
END_VAR

VAR PERSISTENT
	fDaliLineEnergySum				: ARRAY[1..SH_Light.DALI_Param.MAX_DALIV2_LINES] OF LREAL;
	nTotalEnergyKWH					: UINT;
	nMaxControlGearOperatingHours	: UINT;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[
arrfbDALI_EnergyReporting[1].ipDALICommunication := P_DALI_Background.arrfbKL6821Communication[1];
arrfbDALI_EnergyReporting[2].ipDALICommunication := P_DALI_Background.arrfbKL6821Communication[2];
arrfbDALI_EnergyReporting[3].ipDALICommunication := P_DALI_Background.arrfbKL6821Communication[3];
arrfbDALI_EnergyReporting[4].ipDALICommunication := P_DALI_Background.arrfbKL6821Communication[4];
//arrfbDALI_EnergyReporting[5].ipDALICommunication := P_DALI_Background.arrfbKL6821Communication[5];
//arrfbDALI_EnergyReporting[6].ipDALICommunication := P_DALI_Background.arrfbKL6821Communication[6]; // for more update SH_Light.DALI_Param.MAX_DALIV2_LINES


fbLocalSystemTime(
	sNetID:= '', 
	bEnable:= bGetTime, 
	dwCycle:= 2, // cycle time (in seconds) , Synchronization  every 2 seconds.
	dwOpt:= 1, //Bit 0: If this is set, the Windows system time is additionally synchronized cyclically with the hardware clock (RTC) (corresponds to the function NT_SetTimeToRTCTime).
	tTimeout:= tTimeOut, 
	bValid=> bLocalSystemTimeValid, 
	systemTime=> stLocalSystemTime, 
	tzID=> tzID);
	
tdSystemTime := SYSTEMTIME_TO_TOD(systemTime := stLocalSystemTime);
IF	((tdSystemTime > tdMidnight AND tdSystemTime < (tdMidnight + tCheckDuration)) OR (tdSystemTime > tdMorning AND tdSystemTime < (tdMorning + tCheckDuration)) OR
	(tdSystemTime > tdMidDay AND tdSystemTime < (tdMidDay + tCheckDuration)) OR (tdSystemTime > tdEvening AND tdSystemTime < (tdEvening + tCheckDuration))) THEN
	bReadEnergyDataAllLines := TRUE;
END_IF

FOR byEnergyLineIdx := 1 TO SH_Light.DALI_Param.MAX_DALIV2_LINES DO
	IF bReadEnergyDataAllLines = TRUE THEN
		arrReadEnergyData[byEnergyLineIdx] := TRUE;
	END_IF;
	arrfbDALI_EnergyReporting[byEnergyLineIdx](
		bExecute:= arrReadEnergyData[byEnergyLineIdx], 
		DALI_LINE_NUM:= byEnergyLineIdx,
		bCheckActiveEnergy := arrCheckActiveEnergy[byEnergyLineIdx],
		bBusy=> , 
		bActionBusy=> , 
		bErr=>, 
		nErrorId=> ,
		bDone =>  arrDone[byEnergyLineIdx]);
	arrfbRTrigDone[byEnergyLineIdx](CLK := arrDone[byEnergyLineIdx], Q => arrRTrigDone[byEnergyLineIdx]);
	IF arrRTrigDone[byEnergyLineIdx] THEN
		bReadEnergyDataAllLines := FALSE;
		arrReadEnergyData[byEnergyLineIdx] := FALSE;
		nMaxControlGearOperatingTime[byEnergyLineIdx] := 0;
		FOR byCount := 1 TO 63 DO
			fDaliLineEnergySumTmp[byEnergyLineIdx] := fDaliLineEnergySumTmp[byEnergyLineIdx] + SH_Light.GVL_DALI.g_arrEnergyData[byEnergyLineIdx, byCount].fActiveEnergy;
			nMaxControlGearOperatingTimeTmp[byEnergyLineIdx] := MAX(nMaxControlGearOperatingTimeTmp[byEnergyLineIdx], SH_Light.GVL_DALI.g_arrEnergyData[byEnergyLineIdx, byCount].nControlGearOperatingTime);
			IF byCount = 63 THEN
				fDaliLineEnergySumOld[byEnergyLineIdx] := fDaliLineEnergySum[byEnergyLineIdx];
				fDaliLineEnergySum[byEnergyLineIdx] := fDaliLineEnergySumTmp[byEnergyLineIdx];
				fDaliLineEnergyChange[byEnergyLineIdx] := fDaliLineEnergySum[byEnergyLineIdx] - fDaliLineEnergySumOld[byEnergyLineIdx];
				IF fDaliLineEnergyChange[byEnergyLineIdx] < 0 THEN
					fDaliLineEnergyChange[byEnergyLineIdx] := 0;
				END_IF
				nTotalEnergyKWHTmp := TO_UINT(TRUNC((fDaliLineEnergySumOld[byEnergyLineIdx] + fDaliLineEnergyChange[byEnergyLineIdx])*EXPT(10,-3))); //The line above checks for for negative values. As so the conversion to UINT is appropriate.
				fDaliLineEnergySumTmp[byEnergyLineIdx] := 0;
				nMaxControlGearOperatingTime[byEnergyLineIdx] := nMaxControlGearOperatingTimeTmp[byEnergyLineIdx];
				nMaxControlGearOperatingTimeTmp[byEnergyLineIdx] := 0;
			END_IF
		END_FOR
	END_IF 
	nMaxControlGearOperatingHoursTmp := MAX(nMaxControlGearOperatingHoursTmp, TO_UINT(TRUNC(nMaxControlGearOperatingTime[byEnergyLineIdx]*EXPT(60,-2)))); //Maximum of positive numbers are positive. As so the conversion to UINT is appropriate.	
END_FOR;
nMaxControlGearOperatingHours := nMaxControlGearOperatingHoursTmp;
nTotalEnergyKWH := nTotalEnergyKWHTmp;

GVL_AHDataModbus.nMaxControlGearOperatingHours := nMaxControlGearOperatingHours;
GVL_AHDataModbus.nTotalEnergyKWH := nTotalEnergyKWH;

]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>