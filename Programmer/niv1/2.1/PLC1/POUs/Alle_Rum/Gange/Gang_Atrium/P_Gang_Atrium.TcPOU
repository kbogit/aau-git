<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="P_Gang_Atrium" Id="{c958fcbf-91bf-440c-9d19-bf3acacd485b}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM P_Gang_Atrium
VAR

	arrfbLysGruppe			: ARRAY [1..2] OF FB_Light_Type_B;
	arrstDaliSetupGruppe	: ARRAY[1..2] OF SH_Light.ST_DALI_RoomSetup := 
	
													[(	byShrtAdr_Prim := 1, 
														byGrpAdr_Prim := 2, 
														eMod_Prim := E_DALIAddressType.Group, 
														byShrtAdr_Sec := 1, 
														byGrpAdr_Sec := 1, 
														eMod_Sec := E_DALIAddressType.Short, 
														//byShrtAdr_Supl := 1,
														//eMod_Supl := E_DALIADDRESSTYPE.Group,
                                                        byGrpAdr_Supl := 1, 
														DALI_LINE_NUM_PRIM := arrDALI_LINE_NUM_LIGHT[1], 
														DALI_LINE_NUM_SEC := 0, //0 = ingen zonestyring/vinduerække
														DALI_LINE_NUM_SUPL := arrDALI_LINE_NUM_PENDANTS[1]),
														
													(	byShrtAdr_Prim := 1, 
														byGrpAdr_Prim := 2, 
														eMod_Prim := E_DALIAddressType.Group, 
														byShrtAdr_Sec := 1, 
														byGrpAdr_Sec := 1, 
														eMod_Sec := E_DALIAddressType.Short, 
														byShrtAdr_Supl := 63, 
														DALI_LINE_NUM_PRIM := arrDALI_LINE_NUM_LIGHT[2], 
														DALI_LINE_NUM_SEC := 0, 
														DALI_LINE_NUM_SUPL := arrDALI_LINE_NUM_PENDANTS[2])];
														
	arrstLiveDataGruppe		: ARRAY [1..2] OF SH_Light.ST_LiveData;
	//stLiveData AT %MB22	: SH_Light.ST_LiveData;
	
	arrRunTuningGruppe: ARRAY[1..2] OF BOOL;
	
	
	
	bTopButtonZone1			: BOOL;
	bTopButtonZone1_Visu	: BOOL;
	bBottomButtonZone1		: BOOL;
	bBottomButtonZone1_Visu	: BOOL;
	bButtonZone2			: BOOL;
	bNeighborRoomsPir		: BOOL;
	fLuxOn					: REAL;
	fLuxDim					: REAL ;
	tPIRDim					: TIME ;
	tPIROff					: TIME ;
	fOffsetSec				: REAL := 20;



// Sensor Settings
	//fbSensor					: SH_Light.FB_NIKO_P46xx_1Pcs;
	//fbSensor					: SH_Light.FB_NIKO_P46xx_2Pcs;
	arrfbSensorLine				: ARRAY[1..2] OF SH_Light.FB_NIKO_P46xx_4Pcs; 
	//bySensorAddr				: BYTE := 17;
	//arrSensorAddr				: ARRAY[1..2] OF BYTE := [5,6];
	arrSensorAddr				: ARRAY[1..2] OF ARRAY[1..4] OF BYTE := [[1,2,3,4],[5,6,7,8]];
	//bInitialize					: BOOL := TRUE;
	arrInitialize				: ARRAY[1..2] OF BOOL := [TRUE,TRUE];
	//stDaliSensorSetup			: ST_DALI_NIKOP46SetupData;
	arrstDaliSensorSetup		: ARRAY[1..2] OF ST_DALI_NIKOP46SetupData;
	//bInitErr					: BOOL;
	//bInitDone					: BOOL;
	arrInitErr				: ARRAY [1..2] OF ARRAY[1..4] OF BOOL;
	arrInitDone				: ARRAY [1..2] OF ARRAY[1..4] OF BOOL;
	arrSensorScales				: ARRAY[1..2] OF ARRAY[1..10] OF SH_Light.ST_DALI_SensorScaleMode :=	[	[	(fMeassureMaxSensor := rMeassure_Zone7, fReadMaxSensor := rRead_Zone7),
																												(fMeassureMaxSensor := rMeassure_Zone7, fReadMaxSensor := rRead_Zone7),
                                                                                                                (fMeassureMaxSensor := rMeassure_Zone7, fReadMaxSensor := rRead_Zone7),
																												(fMeassureMaxSensor := rMeassure_Zone7, fReadMaxSensor := rRead_Zone7),																					
																												6(())],

																											[	(fMeassureMaxSensor := rMeassure_Zone7, fReadMaxSensor := rRead_Zone7),
																												(fMeassureMaxSensor := rMeassure_Zone7, fReadMaxSensor := rRead_Zone7),	
                                                                                                                (fMeassureMaxSensor := rMeassure_Zone7, fReadMaxSensor := rRead_Zone7),
																												(fMeassureMaxSensor := rMeassure_Zone7, fReadMaxSensor := rRead_Zone7),																				
																												6(())]
																										];
	
																						
	bCancelHoldTimerOccupancy	: BOOL;
(*	eEventPriorityOccupancy		: E_DALIEventPriority := E_DALIEVENTPRIORITY.Middle;
	nHoldTimerOccupancy			: WORD := 5; // Value in s. 	
	nReportTimerOccupancy		: BYTE := 120; // Value in s, Preset manufacturer value
	nDeadtimeTimerOccupancy		: WORD := 100; // Value in ms, Predefined Value of DALI Standard
	bCancelHoldTimerOccupancy	: BOOL;
	nSensitivityOccupancy		: BYTE:= 3; //setting Sensivity (0..4) 0 (Off), 1 (Min), 2(Low), 3(High) and 4 (Max)

	bEnableLuxEvent				: BOOL;
	eEventPriorityBrightness	: E_DALIEventPriority := E_DALIEVENTPRIORITY.Middle;
	nDeadtimeTimerBrightness	: WORD := 1500; // Value in ms, Predefined Value of DALI Standard
	nHysteresisBrightness		: BYTE := 2; // Value in %
	nHysteresisMinBrightness	: BYTE := 10; // Absolute Value, depending on the manufacturer specific resolution
	nReportTimerBrightness		: BYTE := 120; // Value in s, Preset manufacturer value
*)

//(//////
	//ModbusComm setup
	
	fbWriteSPLuxLevel			: SH_Light.FB_TwoVal_SelectOne_RTrigChange;
	fbWritePirDelayTIme			: SH_Light.FB_TwoVal_SelectOne_RTrigChange;
	stRoomDataPLC				: SH_Light.ST_RoomDataPLC	:=	(	uiPirOffDelayTime	:= 30,
																	uiSpLuxLevel		:= 500,
																	uiPirDimDelayTime	:= 15,
																	uiSpDimLuxLevel		:= 200
																);
	fbBallastOnHours			: SH_Light.FB_CountOnHours;
	bEnableHourCount			: BOOL := TRUE;								
	
	//Non-persistent modbus data
	bPirActive_MB			AT%MX500.0	: BOOL;				//bPirLys i gammel kode
	uiActLuxLevel_MB		AT%MB342		: UINT;				//intHMIAktueltLux i gammel kode
	uiActLightLevelPct_MB	AT%MB504		: UINT;				//intDALI_Gruppe1_Lysniveau i gammel kode

//For Conversion
	uiPirOffMinutes						: UINT;
	udTimeScaling						: UDINT := 60000;
	uiLuxOn								: UINT;
	
	//max values checks
	uiMaxLuxLevel						: UINT := 1023;
	uiMaxPirOffMinutes					: UINT := 180;



END_VAR
///////)
VAR CONSTANT
	//Sensor_DALI_LINE_NUM: BYTE := 3;
	arrSensor_DALI_LINE_NUM: ARRAY[1..2] OF BYTE := [1,5];	//korrekt rækkefølge nødvendig //rækkefølge og linje
	arrDALI_LINE_NUM_LIGHT: ARRAY[1..2] OF BYTE := [1,3]; //korrekt rækkefølge nødvendig //rækkefølge og linje 
	arrDALI_LINE_NUM_PENDANTS: ARRAY[1..2] OF BYTE := [0,3]; //korrekt rækkefølge nødvendig. 0 = ingen pendler

END_VAR
VAR PERSISTENT
	stPirSensorData: SH_Light.ST_DALI_Sensor;
	arrstPirSensorDataLine: ARRAY[1..2] OF SH_Light.ST_DALI_Sensor; //hvad kan den her ??
	arrstTuneDataGruppe: ARRAY [1..2] OF SH_Light.ST_TuneData_EX;

	uiPirOffDelayTime_MB	AT%MB502	    : UINT;				//intHMI_Pir_SetValue i gammel kode
	uiSPLuxLevel_MB			AT%MB344	    : UINT;				//intHMI_Lux_SetValue i gammel kode
	uiBallastOnHours_MB		AT%MB310		: UINT;				//dintHMILysbraendtimer1 i gammel kode
	byOnHoursOverflowCount				: BYTE;
END_VAR

///////)






]]></Declaration>
    <Implementation>
      <ST><![CDATA[A_Buttons();
A_LightCtrl();
A_Sensor();
A_Modbuscomm();]]></ST>
    </Implementation>
    <Action Name="A_Buttons" Id="{600fa983-4385-4e61-a994-6428f4bb45b1}">
      <Implementation>
        <ST><![CDATA[bTopButtonZone1		:= bTopButtonZone1_Visu;
bBottomButtonZone1	:= bBottomButtonZone1_Visu;
]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_LightCtrl" Id="{96f1c6aa-e5e8-48fb-a209-487f10bf8f4d}">
      <Implementation>
        <ST><![CDATA[bNeighborRoomsPir:=	P_Rum_2_145.stPirSensorData.bPrc OR
									P_Rum_3_155.stPirSensorData.bPrc OR
									P_Gang_2_143A.stPirSensorData.bPrc OR
									P_Gang_7_153.stPirSensorData.bPrc OR
									P_Rum_2_135.stPirSensorData.bPrc OR
GVL_AHDataModbus.arrAH_NeighborRoomsPir  [4] [0] OR //2-1 
GVL_AHDataModbus.arrAH_NeighborRoomsPir  [4] [1]  OR//2-1 
GVL_AHDataModbus.arrAH_NeighborRoomsPir  [4] [2]  OR//2-1 
GVL_AHDataModbus.arrAH_NeighborRoomsPir  [18] [0] OR//5-1
GVL_AHDataModbus.arrAH_NeighborRoomsPir  [18] [1] OR//5-1
GVL_AHDataModbus.arrAH_NeighborRoomsPir  [5] [0]  OR//2-2
GVL_AHDataModbus.arrAH_NeighborRoomsPir  [5] [1]  OR//2-2
GVL_AHDataModbus.arrAH_NeighborRoomsPir  [5] [2]  OR//2-2
GVL_AHDataModbus.arrAH_NeighborRoomsPir  [5] [3]  OR//2-2
GVL_AHDataModbus.arrAH_NeighborRoomsPir  [5] [4]  OR//2-2
GVL_AHDataModbus.arrAH_NeighborRoomsPir  [5] [5]  OR//2-2
GVL_AHDataModbus.arrAH_NeighborRoomsPir  [9] [0]  OR//3-2 
GVL_AHDataModbus.arrAH_NeighborRoomsPir  [9] [1]  OR//3-2 
GVL_AHDataModbus.arrAH_NeighborRoomsPir  [9] [2]  OR//3-2 
GVL_AHDataModbus.arrAH_NeighborRoomsPir [14] [0]  OR//4-2 
GVL_AHDataModbus.arrAH_NeighborRoomsPir [14] [1]  OR//4-2 
GVL_AHDataModbus.arrAH_NeighborRoomsPir [19] [0]  OR//5-2 
GVL_AHDataModbus.arrAH_NeighborRoomsPir [19] [1]  OR//5-2 
GVL_AHDataModbus.arrAH_NeighborRoomsPir [19] [2];  //5-2
//gruppe 6
arrfbLysGruppe[1]( 
	nZoneID:= 1, 
	bButtonZone1:= bTopButtonZone1,
	bBottomButtonZone1 := bBottomButtonZone1, 
	bTopButtonOverride := (GVL_EnOcean.strEnOceanSwitch_AtriumNiveau_PladeB.bT2_ON OR GVL_EnOcean.strEnOceanSwitch_AtriumNiveau_Service.bT2_ON),
	bBottomButtonOverride := (GVL_EnOcean.strEnOceanSwitch_AtriumNiveau_PladeB.bT2_OFF OR GVL_EnOcean.strEnOceanSwitch_AtriumNiveau_Service.bT2_OFF),
	//BButtonZone2:= bButtonZone2,
	//bNoButtons := TRUE,
	bNeighborRoomsPir	:=	bNeighborRoomsPir,
	fLuxOn:= fLuxOn, 
	fLuxDim:= fLuxDim, 
	tPIRDim:= tPIRDim, 
	tPIROff:= tPIROff, 
	fOffsetSec:= fOffsetSec, 
	bReInit:= , 
	stDaliSetup:= arrstDaliSetupGruppe[1], 
	ipCommunication_Prim:= P_DALI_Background.arrfbKL6821Communication[arrDALI_LINE_NUM_LIGHT[1]], 
	//ipCommunication_Sec:= P_DALI_Background.arrfbKL6821Communication[arrDALI_LINE_NUM_LIGHT[1]], //samme som lyslinjen, hvis den ikke eksisterer
	//ipCommunication_Supl:= P_DALI_Background.arrfbKL6821Communication[arrDALI_LINE_NUM_LIGHT[1]],//samme som lyslinjen, hvis den ikke eksisterer 
	fMinOutputPowerLevelRoom:= 15, 
	fMaxOutputPowerLevelRoom:= 100, 
	nCycleTimeInMS:= SH_Light.DALI_Param.nPlcTaskCycleTimeInMS*nDimCmdCycleTimeFactor , 
	bRunTuning:= arrRunTuningGruppe[1], 
	bOccupiedRoom=> , 
	bError_Prim=> , 
	nError_Prim=> , 
	stTuneData:=arrstTuneDataGruppe[1] , 
	stPirSensorData:= stPirSensorData, 					//samme sensordata
	stLiveData:= arrstLiveDataGruppe[1]);

//gruppe 15	
arrfbLysGruppe[2]( 
	nZoneID:= 1, 
	bButtonZone1:= bTopButtonZone1,
	bBottomButtonZone1 := bBottomButtonZone1, 
	bTopButtonOverride := (GVL_EnOcean.strEnOceanSwitch_AtriumNiveau_PladeB.bT2_ON OR GVL_EnOcean.strEnOceanSwitch_AtriumNiveau_Service.bT2_ON),
	bBottomButtonOverride := (GVL_EnOcean.strEnOceanSwitch_AtriumNiveau_PladeB.bT2_OFF OR GVL_EnOcean.strEnOceanSwitch_AtriumNiveau_Service.bT2_OFF),
	//bButtonZone2:= bButtonZone2,
	bNoButtons := TRUE,
    bNeighborRoomsPir	:=	bNeighborRoomsPir,
	fLuxOn:= fLuxOn, 
	fLuxDim:= fLuxDim, 
	tPIRDim:= tPIRDim, 
	tPIROff:= tPIROff, 
	fOffsetSec:= fOffsetSec, 
	bReInit:= , 
	stDaliSetup:= arrstDaliSetupGruppe[2], 
	ipCommunication_Prim:= P_DALI_Background.arrfbKL6821Communication[arrDALI_LINE_NUM_LIGHT[2]], 
	//ipCommunication_Sec:= P_DALI_Background.arrfbKL6821Communication[arrDALI_LINE_NUM_LIGHT[2]], //samme som lyslinjen, hvis den ikke eksisterer
	ipCommunication_Supl:= P_DALI_Background.arrfbKL6821Communication[arrDALI_LINE_NUM_LIGHT[2]], //samme som lyslinjen, hvis den ikke eksisterer 
	fMinOutputPowerLevelRoom:= 15, 
	fMaxOutputPowerLevelRoom:= 100, 
	nCycleTimeInMS:= SH_Light.DALI_Param.nPlcTaskCycleTimeInMS*nDimCmdCycleTimeFactor , 
	bRunTuning:= arrRunTuningGruppe[2], 
	bOccupiedRoom=> , 
	bError_Prim=> , 
	nError_Prim=> , 
	stTuneData:=arrstTuneDataGruppe[2] , 
	stPirSensorData:= stPirSensorData, 					//samme sensordata
	stLiveData:= arrstLiveDataGruppe[2]);	]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_ModbusComm" Id="{e8fdf350-6a86-47e4-9ece-a94f4db25fd1}">
      <Implementation>
        <ST><![CDATA[//Manage data for modbus communication

//Manage data for read-only in PLC
stRoomDataPLC.bPirActive			:= stPirSensorData.bPrc;
stRoomDataPLC.uiActLuxLevel			:= TO_UINT(TRUNC(stPirSensorData.fBrightness));
stRoomDataPLC.uiActLightLevelPct	:= TO_UINT(TRUNC(arrfbLysGruppe[1].fbBallast.fActlLgtLvl_Prim));
		//stRoomDataPLC.uiActLightLevelPct	:= TO_UINT(TRUNC(fbLys.fbBallast.fActlLgtLvl_Prim)); //if only one group light control
stRoomDataPLC.uiBallastOnHours		:= uiBallastOnHours_MB; //The calculation for BallastOnHours is stored directly to the MB register below


//Assign data for read-only to MB registers
bPirActive_MB			:= stRoomDataPLC.bPirActive;
uiActLuxLevel_MB		:= stRoomDataPLC.uiActLuxLevel;
uiActLightLevelPct_MB	:= stRoomDataPLC.uiActLightLevelPct;

	//calculate BallastOnHours
	fbBallastOnHours(
		bEnableHourCount	:= bEnableHourCount,
		bPauseCount			:= arrfbLysGruppe[1].fbLightCtrl.bOffZone1,
		uiOnHours			:= uiBallastOnHours_MB,			//OnHours is updated here
		byOverflowCount		:= byOnHoursOverflowCount);


//Manage data for read/write for both PLC and MB registers
fbWriteSPLuxLevel(	nMaxValOut	:= uiMaxLuxLevel,
					nValIn1		:= uiSPLuxLevel_MB,		//nValIn1 takes priotity in case of download or restart
					nValIn2		:= stRoomDataPLC.uiSpLuxLevel,
					nValOut		=> uiLuxOn
				);


fbWritePirDelayTIme(	nMaxValOut	:= uiMaxPirOffMinutes,
						nValIn1		:= uiPirOffDelayTime_MB,		//nValIn1 takes priotity in case of download or restart
						nValIn2		:= stRoomDataPLC.uiPirOffDelayTime,
						nValOut		=> uiPirOffMinutes
					);
					

//Convert read/write modbus data to appropriate datatypes in PLC
fLuxOn	:= TO_REAL(uiLuxOn);			
tPIROff	:= TO_TIME(uiPirOffMinutes*udTimeScaling); //Time conversion defaults to ms

fLuxDim	:= TO_REAL(stRoomDataPLC.uiSpDimLuxLevel);			
tPIRDim	:= TO_TIME(stRoomDataPLC.uiPirDimDelayTime*udTimeScaling); //Time conversion defaults to ms
]]></ST>
      </Implementation>
    </Action>
    <Action Name="A_Sensor" Id="{ff0a5700-d738-4fc8-b4f3-d005e3c027d0}">
      <Implementation>
        <ST><![CDATA[
//fbSensor.ipCommunication := P_DALI_Background.arrfbKL6821Communication[Sensor_DALI_LINE_NUM];

(*//only 1 sensor
fbSensor(
	byShrtAdr:= bySensorAddr,
	bInitialize:= bInitialize, 
	DALI_LINE_NUM:= Sensor_DALI_LINE_NUM, 
 	//bCancelHoldTimerOccupancy:= bCancelHoldTimerOccupancy, 
	stSensorSetup := stDaliSensorSetup,
	bInitErr=> bInitErr, 
	bInitDone=> bInitDone,
	stPirSensorData:= stPirSensorData, 
	arrSensorScales:= arrSensorScales);
	*)

//several sensors
	(*
fbSensor(
	arrShrtAdr:= arrSensorAddr,
	bInitialize:= bInitialize, 
	DALI_LINE_NUM:= Sensor_DALI_LINE_NUM, 
 	//bCancelHoldTimerOccupancy:= bCancelHoldTimerOccupancy, 
	stSensorSetup := stDaliSensorSetup,
	arrInitErr=> arrInitErr, 
	arrInitDone=> arrInitDone,
	stPirSensorData:= stPirSensorData, 
	arrSensorScales:= arrSensorScales);
	*)
(*
arrfbSensor(
	arrShrtAdr:= arrSensorAddr,
	bInitialize:= bInitialize, 
	DALI_LINE_NUM:= Sensor_DALI_LINE_NUM, 
 	//bCancelHoldTimerOccupancy:= bCancelHoldTimerOccupancy, 
	stSensorSetup := stDaliSensorSetup,
	arrInitErr=> arrInitErr, 
	arrInitDone=> arrInitDone,
	stPirSensorData:= stPirSensorData, 
	arrSensorScales:= arrSensorScales);
*)

//stPirSensorData

arrfbSensorLine[1].ipCommunication := P_DALI_Background.arrfbKL6821Communication[arrSensor_DALI_LINE_NUM[1]];
arrfbSensorLine[2].ipCommunication := P_DALI_Background.arrfbKL6821Communication[arrSensor_DALI_LINE_NUM[2]];

arrfbSensorLine[1](
	arrShrtAdr:= arrSensorAddr[1],
	bInitialize:= arrInitialize[1], 
	DALI_LINE_NUM:= arrSensor_DALI_LINE_NUM[1], 
 	//bCancelHoldTimerOccupancy:= arrCancelHoldTimerOccupancyLine[1], 
	stSensorSetup := arrstDaliSensorSetup[1],
	arrInitErr=> arrInitErr[1], 
	arrInitDone=> arrInitDone[1],
	stPirSensorData:= arrstPirSensorDataLine[1], 
	arrSensorScales:= arrSensorScales[1]);


arrfbSensorLine[2](
	arrShrtAdr:= arrSensorAddr[2],
	bInitialize:= arrInitialize[2], 
	DALI_LINE_NUM:= arrSensor_DALI_LINE_NUM[2], 
 	//bCancelHoldTimerOccupancy:= arrCancelHoldTimerOccupancyLine[2], 
	stSensorSetup := arrstDaliSensorSetup[2],
	arrInitErr=> arrInitErr[2], 
	arrInitDone=> arrInitDone[2],
	stPirSensorData:= arrstPirSensorDataLine[2], 
	arrSensorScales:= arrSensorScales[2]);


//Input fra sensorer samles
stPirSensorData.fBrightness		:= MIN(arrstPirSensorDataLine[1].fBrightness, arrstPirSensorDataLine[2].fBrightness);
stPirSensorData.bPrc			:= arrstPirSensorDataLine[1].bPrc OR arrstPirSensorDataLine[2].bPrc;
stPirSensorData.bBrightnessRead	:= arrstPirSensorDataLine[1].bBrightnessRead OR arrstPirSensorDataLine[2].bBrightnessRead;

//Output til sensorer fordeles
IF stPirSensorData.bQueryBrightness THEN
	arrstPirSensorDataLine[1].bQueryBrightness := TRUE;
	arrstPirSensorDataLine[2].bQueryBrightness := TRUE;
ELSE
	arrstPirSensorDataLine[1].bQueryBrightness := FALSE;
	arrstPirSensorDataLine[2].bQueryBrightness := FALSE;
END_IF

]]></ST>
      </Implementation>
    </Action>
  </POU>
</TcPlcObject>